# Лабораторная работа 7

## Содержание
1. [Задание на лабораторную работу](#задание-на-лабораторную-работу)
2. [Ход работы](#ход-работы)  
   2.1. [Установка и подготовка среды](#1-установка-и-подготовка-среды)  
   2.2. [Исходный код](#2-исходный-код)  
   2.3. [Получение AST](#3-получение-ast)  
   2.4. [Генерация LLVM IR](#4-генерация-llvm-ir)  
   2.5. [Оптимизация IR](#5-оптимизация-ir)  
   2.6. [Граф потока управления программы](#6-граф-потока-управления-программы)  
3. [Выводы по работе](#выводы-по-работе)  
4. [Дополнительное задание](#дополнительное-задание)  
   4.1. [Исходный код анализируемых программ](#исходный-код-анализируемых-программ)  
   4.2. [Генерация LLVM IR](#генерация-llvm-ir-1)  
   4.3. [Вывод по дополнительному заданию](#вывод-по-дополнительному-заданию)
5. [Ответы на контрольные вопросы](#ответы-на-контрольные-вопросы)

## Задание на лабораторную работу
Тема лабораторной работы: Преобразование и анализ кода с использованием Clang и LLVM.

<b>Цель работы:</b> Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

### Задание: 

1. Установить Clang и LLVM;

2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

4. Построить граф потока управления (CFG) для оптимизированной программы;

5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

## Ход работы
### 1. Установка и подготовка среды
Установлены следующие инструменты в среде Fedora 41
- `clang` — компилятор языка C/C++;
- `llvm` — инструменты анализа и оптимизации кода;
- `opt` — инструмент для работы с LLVM IR и применения оптимизаций;
- `Graphviz` — инструмент для визуализации кода.  

**Команда:**
```bash
sudo dnf install clang llvm graphviz
```
<div align="center">
  <img src="Установка.png" alt="Пример">
  <br>
  <strong>Рис. 1:</strong> Установка инструментов
</div>

### 2. Исходный код
```C
#include <stdio.h>
int square(int x) {
 return x * x;
}
int main() {
 int a = 5;
 int b = square(a);
 printf("%d\n", b);
 return 0;
}
```

### 3. Получение AST
**Команда:**
```bash
clang -Xclang -ast-dump -fsyntax-only lang_lab7.c
```
<div align="center">
  <img src="AST.png" alt="Пример">
  <br>
  <strong>Рис. 2:</strong> Код построенного абстрактного синтаксического дерева
</div>
<br>

**Основные элементы:**
- Узел `FunctionDecl` для square с параметром x и main без параметров.

- Узел `BinaryOperator` для операции x * x.

- Узел `CallExpr` для вызова square(a) в функции main.

**Вывод:**
AST точно отражает структуру программы, включая объявления функций и операций.

### 4. Генерация LLVM IR
**Команда:**
```bash
clang -S -emit-llvm lang_lab7.c -o lang_lab7.ll
```
<div align="center">
  <img src="LLWM.png" alt="Пример">
  <br>
  <strong>Рис. 3:</strong> Сгенерированный LLVM IR
</div>
<br>

### 5. Оптимизация IR

**Шаг 1: Генерация неоптимизированного IR (O0):**
```bash
clang -O0 -S -emit-llvm lang_lab7.c -o lang_lab7_O0.ll
```
**Шаг 2: Генерация оптимизированного IR (O2):**
```bash
clang -O2 -S -emit-llvm lang_lab7.c -o lang_lab7_O2.ll
```

**Сравнение (diff):**
```bash
diff lang_lab7_O0.ll lang_lab7_O2.ll
```
<div align="center">
  <img src="diff.png" alt="Пример">
  <br>
  <strong>Рис. 4:</strong> Сравнение оптимизированного и неоптимизированного варианта
</div>
<br>

**Изменения после оптимизации:**
- Функция `square` встроена в `main` (-inline - оптимизация).

- Константа 25 подставлена напрямую (-constprop - оптимизация).

- Удалены `alloca`, `load`, `store` (-mem2reg, dce - оптимизация).

**Вывод:**
Оптимизации значительно упростили код, устранив избыточные операции.

### 6. Граф потока управления программы
**Шаг 1: Генерация CFG:**

```bash
opt -passes=dot-cfg -disable-output lang_lab7_O2.ll
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```

<div align="center">
  <img src="Grapth.png" alt="Пример">
  <br>
  <strong>Рис. 5:</strong> Генерация GFG
</div>
<br>

**Шаг 2: Визуализация:**
```bash
xdg-open cfg_main.png
xdg-open cfg_square.png
```
<div align="center">
  <img src="GfgRes.png" alt="Пример">
  <br>
  <strong>Рис. 6:</strong> Визуализация GFG
</div>
<br>

**Результат:**

- Граф для `main` содержит один блок (после оптимизации).

- Граф для `square` показывает блок с операцией `mul`.

**Вывод:**
CFG наглядно демонстрирует упрощение потока управления после оптимизаций.

### Выводы по работе
- Clang — обеспечивает глубокий статический анализ кода через AST (Abstract Syntax Tree) и IR (Intermediate Representation), позволяя исследовать структуру программы и семантику на разных уровнях абстракции.

- Оптимизации LLVM (уровень -O2) — агрессивно трансформируют промежуточное представление (IR), устраняя мертвый код, сводя вычисления к константам и упрощая графы выражений для повышения эффективности.

- Граф управления потоком (CFG) — визуализирует логику выполнения программы, отображая базовые блоки и переходы между ними, что критично для анализа доминаторов, обнаружения циклов и оптимизации условий.

## Дополнительное задание

### Задание:
Вариант 5. Объявление целочисленной константы с инициализацией на языке C/C++
**Задание:** Определите const int LIMIT = 100; и используй в условии.
Проверьте, была ли подставлена константа при оптимизации -constprop
или -O2.

### Исходный код анализируемых программ
**Программа 1 Код с заданным значением a**
```C
#include <stdio.h>
const int LIMIT=100;
int main() {
    int a = 20;
    if(a<LIMIT){
        printf("YES");
    } else {
        printf("NO");
    }
    return 0;
}
```
**Программа 2 Код с динамически задаваймым значением a**
```C
#include <stdio.h>
const int LIMIT=100;
int main() {
    int a;
    scanf("%d", &a)
    if(a<LIMIT){
        printf("YES");
    } else {
        printf("NO");
    }
    return 0;
}
```

### Генерация LLVM IR
**Команда:**
```bash
clang -O2 -S -emit-llvm lang_lab7_2.c -o lang_lab7_2_O2.ll
```

**Результат выполнения для программы 1:**
<div align="center">
  <img src="LLVMP1.png" alt="Пример">
  <br>
  <strong>Рис. 7:</strong> LLVM IR для Программы 1
</div>
<br>

При генерации LLVM IR мы можем увидеть, что в результате оптимизаций компилятор оставил только вызов метода print c указателем на строку "YES", что не показывает подставил ли он константу сразу. Для проверки этого проведеи анализ программы 2. 

**Результат выполнения для программы 2:**
<div align="center">
  <img src="LLVMP2.png" alt="Пример">
  <br>
  <strong>Рис. 8:</strong> LLVM IR для Программы 2
</div>
<br>

При генерации LLVM IR мы можем увидеть, что в результате оптимизаций компилятор в строке "%4 = icmp slt i32 %3, 100" подставил значение константы вместо указателя на ячейку в памяти

### Вывод по дополнительному заданию
В результате выполнения было проверено, что в результате оптимизации -O2 было подставлено значение константы

## Ответы на контрольные вопросы